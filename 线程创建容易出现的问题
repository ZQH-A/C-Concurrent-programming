在传递参数的时候，不管是引用还是值传递或者指针，thread都会将实际参数复制过去
传递参数问题：
1.像int这种简单的类型，尽量使用值传递，防止出现问题
2.使用类类型较为复制的类型，避免隐式传递，使用引用传递，如果使用值传递，会构造两个临时对象造成浪费。
3.如果形式参数有引用，且不想改变实际参数的值，则在形式参数的前面要加个const
4.虽然使用的是引用，但在子线程中改变值并不会影响到主线程中实际参数的值。
5.如果希望子线程中的操作可以改变主线程中的值，则形式参数中使用引用，且不加const，在线程参数中相对的参数加std::ref(参数)

使用类和智能指针作为线程参数：
类中不需要改变值，则在形式参数中使用const的引用，需要改变值：在形式参数中使用引用但不加const，且在线程创建中相对的参数加上std::ref;
使用智能指针unique_ptr（只能有一个指针指向一个对象）作为参数传递，需要在线程创建时，参数前加std::move(参数)，这样会使实际参数失去指向的对象，
形式参数指向对象。

使用detech会出现的问题:
1.在使用函数指针时，如果函数参数中有隐式转换则使用的是引用可能会出现问题，但如果有指针，一定会有问题。
2.形式参数如果使用的是引用，而实际参数与形式参数不相匹配（进行隐式转换），那么这个隐式转换是在主线程执行完还是在主线程没有执行完转换的？
  如果是在主线程执行完后进行转换，那么可能所用到的实际参数已被销毁，程序可能出现异常（非法引用内存）
  解决：在创建子线程时，在需要进行隐式转换的地方，直接用实际参数构建一个临时变量进行传递
